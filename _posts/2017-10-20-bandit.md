---
layout: post
title: Bandit [OverTheWire]
published: true
tags: [OverTheWire, hacking]
image:
  feature: overthewire.png
  teaser: overthewire.png
  credit: OverTheWire.org
---

I decided to write up my solutions for the
[Bandit](http://overthewire.org/wargames/bandit/)
challenges ("wargames") from
[OverTheWire](http://overthewire.org/wargames/).
There are surely a variety of other ways that the challenges can be solved.
I've tried especially hard to explain my actions and not take mysterious leaps
    with the hope that this write-up would actually be educational to those that spend time reading it,
    rather than simply a collection of "answers."

Throughout the wargame, the levels build on one another.
For example, to log in and do level 1, you need the password recovered from completing level 0.
In general, to attempt level N, use the ssh password from level (N-1).

Although it does not explicitly state so for these challenges,
I've learned from other related challenges that
*"data for the levels can be found in the homedirectories. You can look at /etc/bandit_pass for the various level passwords."*

While I'd like to think I'm super smart and can solve all of these by myself,
    the reality exists that I needed help sometimes due to ambiguity in the challenge, issues with the environment, and so forth.
I try my best to cite all of my sources where it is appropriate to do so.
At this point I forget exactly when, but at times I leaned on
[Alexander Clark’s Blog](https://alexandervoidstar.wordpress.com/category/overthewire-org/).

> **Spoiler Alert:**
*I include the passwords for the various levels in plaintext below.
The passwords are added as a comment at the end of the initial `ssh` login command for each level (an example of the format is included below).
I wrote them down this way for my own convenience and I'm not changing that here;
all of the passwords are probably out there somewhere if you really just want those.
From a pedagogical stand point, it is of no value to simply copy the passwords.
Work through the challenges, understand the techniques, learn the tools and creative thinking skills.
If you aren't doing it for that reason, then why oh why even spend time on these challenges?!*

```bash
#Login
$ ssh banditN@bandit.labs.overthewire.org -p 2220   #password=PASSWORD-FOR-LEVEL-N
```

The respective page for each of these challenges includes a description of the level as well as a list of commands that you may need to solve the level.
In some cases they may even provide hints or links to background information about the server environment which is needed.
I **will not** replicate that information here.
Instead, I will link to the relevant Bandit page and I'll assume that you are familiar with the goal of each level.
This has pros and cons but this is what I'm doing for now.

## [Level 0](http://overthewire.org/wargames/bandit/bandit0.html) + [Level 1](http://overthewire.org/wargames/bandit/bandit1.html)

Level 0 is really just about logging into the Bandit server.
To log in to the first (zeroth) level, we use the provided password.
All that one needs to know here is how to use `ssh` to log into a remote server.
The `ssh` command that we use specifies a username (`bandit0`), a hostname (`bandit.labs.overthewire.org`) and a port (`-p 2220`);
    these elements, combined with the provided password, can be put together to log in to the Bandit server to play the games.
That's all there is to it.

Before moving on, make sure you are comfortable with this command as we need it (with a different username/password)
to log in to each and every level for Over The Wire games.

```bash
$ ssh bandit0@bandit.labs.overthewire.org -p 2220   #password=bandit0
```

Once we are logged into the system we have begun level 1.
Congratulations, we completed the first (again, read "zeroth") level!
As the official page indicates (linked in the Level 1 title), we can use commands such as `ls` to list the contents of directories and `cd` to move between directories.
In this level, you should quickly notice the existence of a file named `readme`.
We can use the `cat` command to print the contents of the file to stdout (i.e., write the output to the terminal window).

```bash
$ cat readme
boJ9jbbUNNfktd78OOpsqOltutMc3MY1
```

Great! Now we have the password for level 2.

## [Level 2](http://overthewire.org/wargames/bandit/bandit2.html)

We log into the bandit server as before, noting the difference in the username and password for this level.

```bash
$ ssh bandit1@bandit.labs.overthewire.org -p 2220   #password=boJ9jbbUNNfktd78OOpsqOltutMc3MY1
```

We can again use the `cat` program to display the contents of the file.
You'll notice, however, that `cat -` doesn't get you what you want.
It turns out the `-` is a sort of "alias" for "stdin" which effectively means that when you type `cat -`,
the `cat` program is going to wait for information (e.g., filenames, written text)
    from the user before doing its usual job of writing out the content to stdout.

To communicate to `cat` more clearly that we want to address a file named `-` and not stdin,
simply prefix the filename with a relative path to the file `./-`.
The `./` prefix basically says "look in the current directory,"
So in the end, you are saying "look in the current directory for a file named '-'".

```bash
$ cat ./-
CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9
```

This is a useful insight to keep in mind in the future when dealing with funky filenames.

## [Level 3](http://overthewire.org/wargames/bandit/bandit3.html)

We log into the bandit server as before, noting the difference in the username and password for this level
(I'll stop staying this in subsequent levels as I imagine you're getting more comfortable with this by now...).

```bash
$ ssh bandit2@bandit.labs.overthewire.org -p 2220   #password=CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9
```

In short, `cat` will treat words separated by spaces as if they are separate file names;
i.e., run `cat` on files named "space" and "in" and "this" and "filename".
If I have it straight, this is closer to what `cat` is *intended* to do: con**cat**enate files and output the result.
It just so happens that invoking `cat` on a single file concatenates it with nothing and then writes it out, which can be handy.

Anyhow, this challenge is meant to help us explore how to get `cat` to run on a single file where its name contains spaces.
The trick: "escape" the spaces!
Simply put, this prevents the shell from interpreting the space-separated words as separate arguments to feed to `cat` (pun intended?).
It is actually really easy if you start to write "cat sp" and then hit the tab character - it should auto-complete the line for you,
    escaping spaces appropriately (I suppose this assumes you use a friendly terminal).

```bash
$ cat spaces\ in\ this\ filename
UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK
```

The astute hacker will notice that escaping characters such as spaces applies to other characters beyond spaces.
Stick that in your back pocket.

Alternatively, you could put quotation marks around the filename which "binds" the words together:

```bash
$ cat "spaces in this filename"
UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK
```

Regardless of the approach, we get the password for the next level.
Apparently there are many ways to skin this `cat`... OK I'll stop.


## [Level 4](http://overthewire.org/wargames/bandit/bandit4.html)

```bash
#Login
$ ssh bandit3@bandit.labs.overthewire.org -p 2220   #password=UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK
```

I suppose you could learn to play with `cd` to change directories into the `inhere/` directory;
    then you could use `cat` as before to see the contents of the `.hidden` file.
OR we could just use cat from the home directory.

```bash
$ cat inhere/.hidden
pIwrPrtPN36QITSp3EQaw936yaFoFgAB
```

Easy peasy.

## [Level 5](http://overthewire.org/wargames/bandit/bandit5.html)

```bash
#Login
$ ssh bandit4@bandit.labs.overthewire.org -p 2220   #password=pIwrPrtPN36QITSp3EQaw936yaFoFgAB
```

On this level we are looking for a human-readable file amongst a collection of files.
This is a good time to explore the `file` command.
This is a useful program that tries to determine the file type (seems relevant, right?).

We'll also use the `*` wildcard pattern here to do this quickly and easily.
This wildcard is a "globbing" pattern which makes it easy to specify sets of filenames.
In this case, `*` means *everything*; i.e., invoke our `file` command on every file inside of the `inhere/` directory.

Once we've identified the human-readable file, we can use `cat` as before to view the file contents.

```bash
$ file inhere/*
# output not shown here; the human readable file is “-file07” which has type “ASCII text”
$ cat inhere/-file07
koReBOKuIDDepwhWk7jZC0RTdopnAYKh
```

## [Level 6](http://overthewire.org/wargames/bandit/bandit6.html)

```bash
#Login
$ ssh bandit5@bandit.labs.overthewire.org -p 2220   #password=koReBOKuIDDepwhWk7jZC0RTdopnAYKh
```

This level is similar to the last level,
but this time the goal here is to find a file that is human-readable, 1033 bytes in size, *and* non-executable.
This time we will use one of the most helpful commands out there: `find`.
The `find` command allows you to walk a file hierarchy; here we want to walk the file hierarchy rooted at `inhere/`.
We can also provide a command to `find` that will be executed where it evaluates to true (i.e., "finds" what it is looking for).
The output from the `ls` includes file sizes, so we use `grep` here to look for files with the desired file size.

```bash
$ find inhere/ -ls | grep 1033
  2269    4 -rw-r-----   1 root     bandit5      1033 Sep 16 07:10 inhere/maybehere07/.file2
```

This was the only file that was 1033 bytes in size... seems to easy... let’s check the file type.

```bash
$ file inhere/maybehere07/.file2
inhere/maybehere07/.file2: ASCII text, with very long lines
```

Everything seems to check out! Now get the password (some output trimmed because the end of the file was a little funky)

```bash
$ cat inhere/maybehere07/.file2
DXjZPULLxYr17uwoI01bNLQbtFemEgo7
```

## [Level 7](http://overthewire.org/wargames/bandit/bandit7.html)

```bash
#Login
$ ssh bandit6@bandit.labs.overthewire.org -p 2220   #password=DXjZPULLxYr17uwoI01bNLQbtFemEgo7
```

Same game as the last level, just with different parameters.

Now we need to start our file hierarchy walk starting at the root of the file system (`/`);
thus, the first part of our command (`find / -ls`) says to search and LIST every file in the entire system!
The `-type f` says to only select files (i.e., not directories, etc.).
The (2>&1) keeps the annoying “Permission denied” messages from popping up during the traversal of the file system that find does.
And last, the `grep` tries to identify the bandit7 string,
    which we are told identifies the owner of the file.
This gives us a few hits.

```bash
$ find / -ls -type f 2>&1 | grep bandit7
  2280    4 -rw-r-----   1 bandit7  bandit6        33 Sep 16 07:10 /var/lib/dpkg/info/bandit7.password   <<<<<<<<<<<
  4596    4 -r--------   1 bandit7  bandit7        33 Sep 16 07:10 /etc/bandit_pass/bandit7
  5749    4 drwxr-xr-x   2 bandit7  bandit7      4096 Sep 16 07:10 /home/bandit7
  5796 4088 -rw-r-----   1 bandit8  bandit7   4184396 Sep 16 07:10 /home/bandit7/data.txt
  5797    4 -rw-r--r--   1 bandit7  bandit7       675 Apr  9  2014 /home/bandit7/.profile
  5798    4 -rw-r--r--   1 bandit7  bandit7      3637 Apr  9  2014 /home/bandit7/.bashrc
  5799    4 -rw-r--r--   1 bandit7  bandit7       220 Apr  9  2014 /home/bandit7/.bash_logout
```

The first file in the list seems to check all the boxes;
    it is owned by the user bandit7, owned by the group bandit6.
We further verify that we’ve found the right file by noting that the file size is 33 bytes.
All that is left to do is to go get the password for the next level!

```bash
$ cat /var/lib/dpkg/info/bandit7.password
HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs
```

## [Level 8](http://overthewire.org/wargames/bandit/bandit8.html)

```bash
#Login
$ ssh bandit7@bandit.labs.overthewire.org -p 2220   #password=HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs
```

We've already explored using `grep` (and pattern matching utility).
We can use it here to look for the clue word, "millionth" in the `data.txt` file.

```bash
$ grep "millionth" data.txt
millionth    cvX2JJa4CFALtqS87jk27qwqGhBM9plV
```

We got a hit and sure enough, the password follows where we find the clue word in the file.

## [Level 9](http://overthewire.org/wargames/bandit/bandit9.html)

```bash
#Login
$ ssh bandit8@bandit.labs.overthewire.org -p 2220   #password=cvX2JJa4CFALtqS87jk27qwqGhBM9plV
```

Similar to the previous challenge, we need to search a big file.
This time, however, we don't have a specific word to look for, so `grep` is of no use to us here.

The instructions do define some things we are looking for and point us towards some other commands that might be useful.
For example, `uniq` allows us to pick out the unique instances of words.
The catch?
It only compares adjacent lines.
Thus, to detect duplicates, they need to be adjacent in the file - an assumption we shouldn't make.

So what can we do?
Well, we could `sort` the file first, putting all redundant lines adjacent to one another.
Here, we pipe the output of `data.txt` to `sort`, sorting all of the file lines, and *then* call `uniq`.

```bash
$ cat data.txt | sort | uniq -u
UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR
```

## [Level 10](http://overthewire.org/wargames/bandit/bandit10.html)

```bash
#Login
$ ssh bandit9@bandit.labs.overthewire.org -p 2220   #password=UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR
```

Here is another useful and fun program: `strings`.
Pass a file to `strings` and it will try to find all of the human-readable strings.

We know that we are looking for a human-readable string, and one that starts with a few "=" characters.
Thus, lets use `strings` in conjunction with `grep` to search any human-readable strings that turn up for this pattern.

```bash
$ strings data.txt | grep "==="
7========== the
J========== password
========== is
========== truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk
```

Great!

As an aside, have you ever come across files that render with a whole bunch of bad/random looking characters?
Maybe you've tried invoking `cat` on an executable or something?
Try using `strings` to pull out the human-readable strings;
    you might be surprised at what you find!

## [Level 11](http://overthewire.org/wargames/bandit/bandit11.html)

```bash
#Login
$ ssh bandit10@bandit.labs.overthewire.org -p 2220   #password=truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk
```

Pretty straightforward here: the password is base64 encoded and one of the suggested commands is `base64`.
Upon reading the `man base64` page, we see there is a `-d` flag for decoding.

```bash
$ base64 -d data.txt
The password is IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR
```

Annoyingly, on OS X, `base64` supports a `-D` or `--decode`, but no `-d`.
This is a great example of one of those little, minor, annoying differences between working in a Linux environment vs. an OS X environment.

## [Level 12](http://overthewire.org/wargames/bandit/bandit12.html)

```bash
#Login
$ ssh bandit11@bandit.labs.overthewire.org -p 2220   #password=IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR
```

Ah, good ol' ROT13.
ROT13 is a a simple cipher that replaces a letter with the letter 13 letters after it in the alphabet.
Thus, ROT-ate-13.

For this challenge, we turn to the `tr`anslate utility.
We can use `tr` to translate characters from one string into another characters from string.
Note that characters are translated one at a time.

Here, we can pipe the output of the `data.txt` file into `tr` and specify a ROT13-style translation
    to undo the rotation that has been applied to the characters in the file.
Specifically, we'll specify two strings for `tr` that say "translate a->n, b->o, c->p, ..., z->m, A-N, B->O, C->P, ..., Z->M" - you get the picture.

```bash
$ cat data.txt | tr 'a-zA-Z' 'n-za-mN-ZA-M'
The password is 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu
```

## [Level 13](http://overthewire.org/wargames/bandit/bandit13.html)

NOTE: I referenced this StackOverflow post:
[How to detect the type of compression on the file?](https://stackoverflow.com/questions/19120676/how-to-detect-type-of-compression-used-on-the-file-if-no-file-extension-is-spe/19127748#19127748),
 which helped me identify that the file has a header that suggests the file has been compressed with Gzip (0x1f, 0x8b, 0x08).

```bash
#Login
$ ssh bandit12@bandit.labs.overthewire.org -p 2220   #password=5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu
```

I followed the advice for this level and created a directory under `/tmp` in which we can work using `mkdir`.
To be clear, it was useful to create a directory under `/tmp`, then copy the data file using `cp`, and rename it using `mv`.
An example of this is shown below.

```bash
#tmp directory
$ mkdir -p /tmp/t123
$ cd /tmp/123
#copy data file
$ cp ~/data.txt data
#rename
$ mv data data.hex
#revert the hex dump to binary
$ xxd -r data.hex data
#confirm the compression type
$ file data
data: gzip compressed data, was "data2.bin", from Unix, last modified: Sat Sep 16 07:10:14 2017, max compression
#double-check that the first few bytes match what we thought re: the StackOverflow post linked above.
$ xxd data
0000000: 1f8b 0808 56ce bc59 0203 6461 7461 322e  ....V..Y..data2.
...snip...
```

This was all followed by a repeated process of
1. checking the file types with `file` and `xxd` inspection,
2. using `mv` to rename the file so that I could,
3. further decompress (`gunzip` or `bunzip2`) or unpack (`tar -xvf`) the file.

For many iterations, the file was simply in yet another compressed/archived form; follow steps 1-3 until:

```bash
$ file data8.bin
data8.bin: ASCII text
$ cat data8.bin
The password is 8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL
```

## [Level 14](http://overthewire.org/wargames/bandit/bandit14.html)

```bash
#Login
$ ssh bandit13@bandit.labs.overthewire.org -p 2220   #password=8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL
```

We have now reached the point in these challenges where we are starting to turn to more interesting network tools.
Here we get to use a familiar utility (`ssh`) with a new option, `-i`, which allows us to provide a path to an identity file.
According to the `man ssh` page,

> The default is `~/.ssh/identity` for protocol version 1, and `~/.ssh/id_dsa`, `~/.ssh/id_ecdsa`, `~/.ssh/id_ed25519` and `~/.ssh/id_rsa` for protocol version 2.

Conveniently, the non-standard private key is located in the home directory upon logging in as bandit13.
We can use the `-i` flag to indicate to `ssh` that we want to use that identity file,
    and then provide the `username@host` information for the connection.
Once we are logged into the bandit14 account, we can simply read the password from the bandit password directory.
Note that we have permission to read the password for bandit14 because we are in fact logged in as bandit14.

```bash
$ ssh -i sshkey.private bandit14@localhost
$ cat /etc/bandit_pass/bandit14
4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e
```

## [Level 15](http://overthewire.org/wargames/bandit/bandit15.html)

```bash
#Login
$ ssh bandit14@bandit.labs.overthewire.org -p 2220   #password=4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e
```

We need to make a simple network connection.
Nothing is more simple than using `telnet`!
Here, we can use a very basic form of `telnet` where we provide a host (`localhost`) and port (`30000`).
Once we've used `telnet` to connect to localhost on the designated port,
    we have an open connection to that host on that port.
The challenge prompt suggests that we need to submit the password of the current level, so let's do that.
Upon copy-pasting the bandit14's password into the terminal,
    we immediately get a "Correct!" message along with the password for the next leve.

```bash
$ telnet localhost 30000
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
[I entered:]4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e
Correct!
BfMYroe26WYalil77FoDi9qh59eK5xNr
```

## [Level 16](http://overthewire.org/wargames/bandit/bandit16.html)

```bash
#Login
$ ssh bandit15@bandit.labs.overthewire.org -p 2220   #password=BfMYroe26WYalil77FoDi9qh59eK5xNr
```

This level is similar to the last level, however, we must now use an SSL client to create an SSL connection to localhost;
the SSL client uses SSL encryption, which is needed for this level.
In addition, we are given the hint that the `-ign_eof` may be useful to avoid some errors that may prevent us from completing the level.

The `openssl` utility takes many subcommands;
    one command that can be useful here is the `s_client` command, which
    *"implements a generic SSL/TLS client which can establish a transparent connection to a remote server speaking SSL/TLS.
    It's intended for testing purposes only and provides only rudimentary interface functionality but internally uses mostly all functionality of the OpenSSL ssl library."*
    (According the man page for `openssl`).
In reading the `man s_client` page as well,
    we learn that we need to use the `-connect host:port` option to specify the host and port to connect to
    (since the default `localhost:4443` is not what we need).
Once we have established the SSL connection, we need to submit the password used for *this* level to get the password for the *next* level.

```bash
$ openssl s_client -connect localhost:30001 -ign_eof
CONNECTED(00000003)
…snip…
[I entered:]BfMYroe26WYalil77FoDi9qh59eK5xNr
Correct!
cluFn7wTiGryunymYOu4RcffSxQluehd
```

## [Level 17](http://overthewire.org/wargames/bandit/bandit17.html)

```bash
#Login
$ ssh bandit16@bandit.labs.overthewire.org -p 2220   #password=cluFn7wTiGryunymYOu4RcffSxQluehd
```

We have to do a few things here.
First, we need to identify which ports are open.
A great tool that can help us here is `nmap`.
The `nmap` utility is a network exploration tool that has port scanning capabilities.
Thus, we'll use `nmap` here to scan the target (`localhost`) for open ports.
In the case of this level we are given a hint about the range of port numbers where we should focus our exploration;
    we use the `-p` flag to specify a port range in `nmap`.

```bash
$ nmap localhost -p31000-32000

Starting Nmap 6.40 ( http://nmap.org ) at 2017-09-29 12:59 UTC
Nmap scan report for localhost (127.0.0.1)
Host is up (0.00056s latency).
Other addresses for localhost (not scanned): 127.0.0.1
Not shown: 996 closed ports
PORT      STATE SERVICE
31046/tcp open  unknown
31518/tcp open  unknown
31691/tcp open  unknown
31790/tcp open  unknown   <<<<<<<<<<<<<<<
31960/tcp open  unknown

Nmap done: 1 IP address (1 host up) scanned in 0.07 seconds
```

OK, we've identified the open ports, but which ones are running SSL servers?
To answer that question we can use `openssl s_client` as we did in level 16 to try to connect over SSL to the ports that are open.
I tried them each manually; perhaps you can be more clever.

```bash
$ openssl s_client -connect localhost:31046 -ign_eof
$ openssl s_client -connect localhost:31518 -ign_eof
$ openssl s_client -connect localhost:31691 -ign_eof
$ openssl s_client -connect localhost:31790 -ign_eof
...snip...
```

Some of them simply terminate the connection (because they aren’t running SSL and therefore my connection attempt is invalid).
Some of them support SSL but are running an "echo server," which simply echoes anything you send to it.
The port 31790 is the one that I found that was open, accepts SSL connections, *and* returns the secret for the next level.
It actually returns an RSA key which I have not included here — you’ll have to log in as bandit16 (command above),
    use the openssl s_client command (bolded below),
    and retrieve the key yourself.
I simply copy/pasted the key into a file called `sshkey.private` in the home directory and then used the ssh command (next level) to login as bandit17.

## [Level 18](http://overthewire.org/wargames/bandit/bandit18.html)

You may want to read Level 17 which explains how I obtained `sshkey.private`.
If you have it already, read on.

```bash
#Login - I got an error saying that my sshkey was too open/accessible;
#I eliminated the error by removing access permissions for group and other.
$ chmod go-rwx sshkey.private
$ ssh -i sshkey.private bandit17@localhost
```

This level introduces the use of `diff`, a utility that can compare files and highlight the differences between them.
With this utility in hand, this level is quite easy to solve.
Simply use `diff` to compare the password files; the password for the next level is the only line that has been changed between the two files.

```bash
$ diff passwords.new passwords.old
42c42
< kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd
---
> R3GQabj3vKRTcjTTISWvO1RJWc5sqSXO
```

## [Level 19](http://overthewire.org/wargames/bandit/bandit19.html)

```bash
$ ssh bandit18@bandit.labs.overthewire.org -p 2220   #password=kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd
...snip...
Byebye !
Connection to bandit.labs.overthewire.org closed.
```

Odd. We have the right password, but when we log in as bandit18, the connection is closed immediately.
From this level we know that someone has modified `.bashrc` to log you out when you log in with SSH.
Now what?

Well, if you spend some time reading the SSH man page (or searching online),
    you might come across the following tidbit:
    *"If command is specified [when using ssh to connect to a host], it is executed on the remote host instead of a login shell."*
Ok, so if we issue a command as part of the SSH connection, then it will execute the command and we can bypass the whole login shell business.
What command should we run?
How about our trusty friend `cat`!
That's all we need here to print out the contents of the `readme` file which we are told contains the password for the next level.

```bash
#Login
$ ssh bandit18@bandit.labs.overthewire.org -p 2220 'cat readme'   #password=kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd
...snip...
bandit18@bandit.labs.overthewire.org\'s password: [I entered:] kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd
IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x
```

## [Level 20](http://overthewire.org/wargames/bandit/bandit20.html)

```bash
#Login
$ ssh bandit19@bandit.labs.overthewire.org -p 2220   #password=IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x
```

For this level, we are simply told to run the executable in the home directory with no arguments to learn how it can be used.

```bash
$ ./bandit20-do
Run a command as another user.
  Example: ./bandit20-do id
```

Seems straightforward.
Given the name of the executable, what the executable claims to do, *and* the purpose of this level (i.e., to get to the next level),
    perhaps "another user" means we can run a command as user bandit20.
Let's assume that is true and invoke the executable with `cat` on a file that we can't read, but that user bandit20 can read (i.e., `/etc/bandit_pass/bandit20`).

```bash
$ ./bandit20-do cat /etc/bandit_pass/bandit20
GbKksEFF4yrVs6il55v6gwY5aVje5f0j
```

Onto the next level.

## [Level 21](http://overthewire.org/wargames/bandit/bandit21.html)

```bash
#Login
$ ssh bandit20@bandit.labs.overthewire.org -p 2220   #password=GbKksEFF4yrVs6il55v6gwY5aVje5f0j
```

This level is a little tricky, mostly because of the bandit server infrastructure.
I'll describe how we can work around this below.

For this challenge, we'll use a new tool: `netcat`.
The `netcat` (`nc`) utility allows you to create arbitrary TCP and UDP connections as well as listen for TCP and UDP traffic.
In this challenge, we can use `nc` to listen on a port, to which the `suconnect` script will connect.

Thus, in this level you must have two open connections,
    but this is not as straight forward as you might think because of the Over The Wire ssh infrastructure [(described here)](http://overthewire.org/help/sshinfra.html).
Fortunately that page provides some insightful information.
We still need two terminals (see the next two snippets below).
Here is the order in which commands should be executed:

1. In Terminal 2, create an SSH connection to the bandit game with port forwarding from `localhost` to the bandit server — a docker container.
2. In Terminal 1, create an SSH connection to `localhost` over the forwarded port — this connects you to the same docker container from step 1.
(*After steps 1 and 2 you have two connections to the same container on the bandit server.*)
3. In Terminal 1, start a `netcat` (`nc`) server to listen for connections and keep an open connection with a client.
4. In Terminal 2, use the `suconnect` script to connect to the `netcat` server created in step 3.
5. In Terminal 1, copy and paste the password for this level and hit enter.
   The `suconnect` script will compare this password (which it receives over the connection to the `netcat` server running on `localhost`)
   and then send back the password for the next level.

**Terminal 1:**

*This terminal will connect to the port forwarded SSH connection (created in Terminal 2 below) from `localhost`
which will forward the connection to the same container on the bandit server.*

```bash
$ ssh -l bandit20 -p 1234 localhost
…snip…
$ nc -l 55555
GbKksEFF4yrVs6il55v6gwY5aVje5f0j   #<<< password for this level (level 20)
gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr   #<<< new password! (for level 21) — success!
```

**Terminal 2:**

*This terminal will setup the port forwarded SSH connection from localhost to the bandit server and exist as one connection to the bandit server.*

```bash
$ ssh -l bandit20 -p 2220 -L 1234:localhost:22 bandit.labs.overthewire.org
…snip…
$ ./suconnect 55555
Read: GbKksEFF4yrVs6il55v6gwY5aVje5f0j
Password matches, sending next password
```

## [Level 22](http://overthewire.org/wargames/bandit/bandit22.html)

```bash
#Login
$ ssh bandit21@bandit.labs.overthewire.org -p 2220   #password=gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr
```

To complete this level we need to understand yet another useful tool: `cron`.
`cron` is a daemon that executes commands at scheduled intervals.
It turns out that the directory `/etc/cron.d/` holds existing "cron jobs".
We need to inspect this directory to identify cron jobs that are running;
    we are particularly interested in those jobs that pertain to this level.
Below is an annotated script of some of my exploration.

```bash
$ ls /etc/cron.d/
cron-apt  cronjob_bandit22  cronjob_bandit23  cronjob_bandit24  php5

# Here we can see what script is being run as a cronjob (relevant to this level)...
$ cat /etc/cron.d/cronjob_bandit22
@reboot bandit22 /usr/bin/cronjob_bandit22.sh &> /dev/null
* * * * * bandit22 /usr/bin/cronjob_bandit22.sh &> /dev/null

# And here we can see that the password is being cat-ed to a file in /tmp/ that we can read
$ cat /usr/bin/cronjob_bandit22.sh
#!/bin/bash
chmod 644 /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv
cat /etc/bandit_pass/bandit22 > /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv
```

Ok, so we identified a script that is being run as part of a cron job.
The script is owned by ther user bandit22 and it `cat`s its password to a file in the `/tmp` directory.
The script also adjusts the permissions of the aforementioned file such that we should be able to read it
    (according to `chmod 644`, group members and "others" have permission to read the file).
Thus, if we `cat` the contents of that file, we can get the password for the next level.

```bash
# Thus, reading the file yields the next password!
$ cat /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv
Yk7owGAcWjwMVRwrTesJEwB7WVOiILLI
```

## [Level 23](http://overthewire.org/wargames/bandit/bandit23.html)

```bash
#Login
$ ssh bandit22@bandit.labs.overthewire.org -p 2220   #password=Yk7owGAcWjwMVRwrTesJEwB7WVOiILLI
```

Again, we are exploring cron jobs in this level.
The purpose of this exercise is to practice reading scripts written by other people.
Therefore, make sure you understand what the script for this level is doing!

Start by digging in and finding out what is being run as a cron job.

```bash
$ ls /etc/cron.d/
cron-apt  cronjob_bandit22  cronjob_bandit23  cronjob_bandit24  php5

$ cat /etc/cron.d/cronjob_bandit23
@reboot bandit23 /usr/bin/cronjob_bandit23.sh  &> /dev/null
* * * * * bandit23 /usr/bin/cronjob_bandit23.sh  &> /dev/null
```

Ok, so we've identified the script that is being run for this level.
Let us now examine what the script itself is doing.

```bash
$ cat /usr/bin/cronjob_bandit23.sh
#!/bin/bash

myname=$(whoami)
mytarget=$(echo I am user $myname | md5sum | cut -d ' ' -f 1)

echo "Copying passwordfile /etc/bandit_pass/$myname to /tmp/$mytarget"

cat /etc/bandit_pass/$myname > /tmp/$mytarget
```

In short, we see that the password for the user running the script is `cat`-ed to a tmp file (the last line in the script).
Also, notice that the tmp file's name is determined by the command from the `mytarget=...` line.
The tricky thing here is that the script computes the MD5 digest of the string "echo I am a user $myname"
    (where `$myname` is set to the name of the user running the script) and uses that as the `$mytarget` filename.

If we run the script directly, we can see it in action and read the contents of the file.

```bash
$ bash /usr/bin/cronjob_bandit23.sh
Copying passwordfile /etc/bandit_pass/bandit22 to /tmp/8169b67bd894ddbb4412f91573b38db3
$ cat /tmp/8169b67bd894ddbb4412f91573b38db3
Yk7owGAcWjwMVRwrTesJEwB7WVOiILLI
```

While this is good to do and know and see, it isn't quite what we want.
We ran the script as bandit22 which, ultimately helps us recover the name of the target file for bandit22 and thus the password for this level (which we already had...).

Now let's check what we get if `$myname` is changed to be bandit23 instead of bandit22.
Note here that I'm just running the interesting line where `mytarget=...` is defined.
We do this manually since we can't run the script *as* bandit23;
    thus, we can't see what the target file is named by simply running the script - but this is what we want to know.
We can, however, just manually type the string since we know what the script is doing (i.e., substituting bandit23 for `$myname`),
    and determine what `$mytarget` evaluates to.
Tricky, right?

```bash
$ echo I am user bandit23 | md5sum | cut -d ' ' -f 1
8ca319486bfbbc3663ea0fbe81326349

# Now, if we cat that file in /tmp/ we will get the password we are after!
$ cat /tmp/8ca319486bfbbc3663ea0fbe81326349
jc1udXuA1tiHqjIsL8yaapX5XIAI6i0n
```

## [Level 24](http://overthewire.org/wargames/bandit/bandit24.html)

```bash
#Login
$ ssh bandit23@bandit.labs.overthewire.org -p 2220   #password=jc1udXuA1tiHqjIsL8yaapX5XIAI6i0n
```

Yet another cron job level.
We are told up front that this level, however, requires you to create your own shell-script.

Let us start by finding out what the cron job is doing.

```bash
$ cat /etc/cron.d/cronjob_bandit24
@reboot bandit24 /usr/bin/cronjob_bandit24.sh &> /dev/null
* * * * * bandit24 /usr/bin/cronjob_bandit24.sh &> /dev/null
```

And here is the script being run for this cron job.

```bash
$ cat /usr/bin/cronjob_bandit24.sh
#!/bin/bash

myname=$(whoami)

cd /var/spool/$myname
echo "Executing and deleting all scripts in /var/spool/$myname:"
for i in * .*;
do
    if [ "$i" != "." -a "$i" != ".." ];
    then
    echo "Handling $i"
    timeout -s 9 60 ./$i
    rm -f ./$i
    fi
done
```

The cronjob simply executes all the scripts in the noted folder (where `$myname` = bandit24) and then deletes them.
What we can do is craft a small script and copy it to this directory, where it will be executed.
Note that this is possible because the folder is writable by anyone in group bandit23 (how convenient for us!).

Our script (`b23.sh`) simply `cat`s bandit24's password to a file in `/tmp/` which we can subsequently read.

**b23.sh:**

```bash
#!/bin/bash
cat /etc/bandit_pass/bandit24 >> /tmp/bandit24pass
```

After composing our script, we change its permissions so that anyone executing the script does indeed have the necessarily permissions to do so;
    then copy the script to the directory noted above so that the cronjob executes it.
Wait a few seconds and then check the tmp file that our script writes to.

```bash
$ chmod 777 b23.sh
$ cp b23.sh /var/spool/bandit24/b23.sh
$ cat /tmp/bandit24pass
UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ
```

Voila!

## [Level 25](http://overthewire.org/wargames/bandit/bandit25.html)

```bash
#Login
$ ssh bandit24@bandit.labs.overthewire.org -p 2220   #password=UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ
```

This was one of the most fun (my favorite?) levels in the Bandit challenges! 
We have to connect to a port and brute-force a PIN code - fun!

Here's how I thought about it:

1. Use `echo` and bash expansions to construct strings with the password from the previous level (UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ) followed by every combination of 0..9 for each of the four PIN digits. 
2. Pipe this into `tr`, which yields repeating lines of our old password, then a PIN guess, then our old password, then another PIN guess, and so on. 
3. Then using `paste`, we "stitch" together two lines (i.e., so that our old password and one PIN guess reside on one line, separated by a single space. 
    This part was a bit of a hack to get the text into the desired format. 
4. The result of all of this is piped to the daemon running on localhost port 30002.

I will let you play around with parts of this pipeline. 

To be honest, my solution doesn’t show -which- PIN reveals the correct answer, but it does print the correct answer to `stdout` when it is encountered in my PIN attempts.
Rumor has it that the PIN changes over time anyways, so who cares what the PIN is — we want the password!

```bash
$ echo UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ\ {0..9}{0..9}{0..9}{0..9} |  tr " " "\n" | paste -d ' ' - - | nc localhost 30002
...snip...
Correct!
The password of user bandit25 is uNG9O58gUE7snukf3bvZ0rxhtnjzSGzG
```

Alternatively, you could write a script. 
I played with both approaches, but I like the pipeline approach better. 
In case you are interested though, I've included `brute.sh` below. 

```bash
#!/bin/bash
echo "brute-forcing port 30002:"
for i in $(seq 0000 9999);
do
echo "---------------"
echo "Testing: $i"
echo "---------------"
echo UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ $i | netcat localhost 30002
done
================
```

Have fun!

## [Level 26](http://overthewire.org/wargames/bandit/bandit26.html)

```bash
#Login
$ ssh bandit25@bandit.labs.overthewire.org -p 2220   #password=uNG9O58gUE7snukf3bvZ0rxhtnjzSGzG
```

I logged into bandit25 but it sounds like we are then supposed to turn around and log into bandit26 with an SSH key that resides in bandit25's home directory. 

```bash
#Login (again...)
$ ssh bandit26@localhost -i bandit26.sshkey
```

But upon trying to login as bandit26 we get logged out immediately... 
If you are watchful, you’ll notice that normal Over The Wire output is rendered, but at the end there is some text that is also rendered:  "bandit 26". 
I wonder if this has something to do with the fact that bandit26 is using an irregular login shell (alluded to in this level's prompt)? 
Logged in as bandit25, let's see what bandit26 is running for its login shell (specified in the `/etc/passwd` file).

```bash
$ cat /etc/passwd | grep bandit26
bandit26:x:11026:11026:bandit level 26:/home/bandit26:/usr/bin/showtext
```

And now let’s examine what this "showtext" script is doing.

```bash
bandit25@bandit:~$ cat /usr/bin/showtext
#!/bin/sh

export TERM=linux

more ~/text.txt
exit 0
```

Aha, it invokes `more` on the `text.txt` file in bandit26’s home directory.

The next bit is not necessarily straightforward, but bare with me here. 
Shrink the terminal window to be only a few lines tall (explanation for this below). 
Now try to log in again:


```bash
$ ssh bandit26@localhost -i bandit26.sshkey
# Type “v”
# Type “:r /etc/bandit_pass/bandit26”
# Now you’ll see the password appear:
5czgV9L3Xx8JPOyRbXh6lQbmIOWvPT6Z
```

**EXPLANATION:**

> The whole reason I decided to write my solutions for these challenges was because of *this* level. 
> I had no idea why this level worked. 
> It felt so magical. 
> I looked around on the web and read a bunch and finally came to understand *why* this works. 
> Of course it makes sense now, but hind sight is often 20/20. 
> Below, I describe some of my thoughts and findings. 

The login shell for bandit26 uses the `/usr/bin/showtext` script shown above (not a traditional shell like bash, as the hint for this problem suggested). 
In the `showtext` script, the `more` command is used to display the content of the `text.txt` file. 
The `more` command provides "a filter for paging through text one screenful at a time." 
If the terminal screen is too big (i.e., displays more lines than there are lines of text in the `~/text.txt` file), 
  then more will print all of the content to the screen and "finish" 
  (i.e., it has paged everything in the file given to `more`, so that command completes, and then the subsequent `exit 0` command is executed). 

The trick to this problem is to shrink the terminal screen so that `more` does not simply print the file contents and finish; 
  rather, we want to keep the `more` process alive for a bit. 
By shrinking the terminal size, when `more ~/text.txt` is called, 
  more does not finish because it is waiting for the user to continue paging/scrolling the content from the file. 
Thus, at this point, we are "sitting inside of" the `more` command and we can use its features — technically put, we are in the "interactive" mode of `more`.

As the man page reads for the `more` command, 
  "interactive commands are based on vi". 
Thus, we press "v" to activate vi/vim-like input. 
Then, if you are a vi/vim user, you know that ":r" lets you read a file. 
At this point, we are running as bandit26 and we have the ability to read a file — so why not read a file that has the password? 

As has been the case for all of the previous challenges, the plaintext password for level N of the bandit challenges lives in /etc/bandit_pass/banditN. 
The issue is that you have to be running as user banditN to read the corresponding password file. 
Lucky, within our little vi environment within the process executing the `more` command, we are running as bandit26, 
  so we can read the corresponding password file in `/etc/bandit_pass/bandit26`.

As an aside, I think `more` will use the default editor if one is not specified in the environment variables. 
The EDITOR defaults to vi if neither VISUAL or EDITOR is defined (at least this is what I gleaned from the man page).


## [Level 27](http://overthewire.org/wargames/bandit/bandit27.html)

*At the time of working on these challenges, there is a page for Level 26 => Level 27, but no exercise has actually been created yet. Onto other challenges... :D*

## Wrapping up

If you've completed these challenges you've surely added some cruft to your `~/.known_hosts` file.
I looked around to see how others manage their `known_hosts` file and found the following script.
Simply copy-paste the following script into a file named `ssh_known_host_cleanup.sh` and make it executable (`chmod +x ssh_known_host_cleanup.sh`).

```bash
#!/bin/bash
#
# A simple shell script to clean (delete)  ~/.known_hosts file hostname entry.
# -------------------------------------------------------------------------
# Copyright (c) 2007 nixCraft project <http://cyberciti.biz/fb/>
# This script is licensed under GNU GPL version 2.0 or above
# -------------------------------------------------------------------------
# This script is part of nixCraft shell script collection (NSSC)
# Visit http://bash.cyberciti.biz/ for more information.
# -------------------------------------------------------------------------
#
# Examples:
# ./ssh_known_host_cleanup.sh www-03.nixcraft.net.in
# ./ssh_known_host_cleanup.sh [leviathan.labs.overthewire.org]:2223
#
host="$1"

[[ $# -eq 0 ]] && { echo "Usage: $0 host.name.com"; exit 1;}

ips=$(host "$host" | awk -F'address' '{ print $2}' | sed -e 's/^ //g')
ssh-keygen -R "$host"
for i in $ips
do
    ssh-keygen -R "$i"
done
```

I updated the script's comments but I don't think I had to touch anything else (citation information in the comments).
You can read the comments to see examples of how I use the script, or you can just enter:

```bash
./ssh_known_host_cleanup.sh [leviathan.labs.overthewire.org]:2223
```
